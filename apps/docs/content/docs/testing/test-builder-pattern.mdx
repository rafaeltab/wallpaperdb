---
title: TesterBuilder Pattern
description: Learn the composable, type-safe TesterBuilder pattern for setting up test infrastructure with Testcontainers.
---

The TesterBuilder pattern provides a composable, type-safe way to set up test infrastructure using Testcontainers. Instead of manually managing Docker containers in each test file, you compose reusable builders that handle setup and cleanup automatically.

## Core Concepts

### Composition Over Configuration

Instead of writing imperative setup code, you **declare** what infrastructure you need:

```typescript
// Old Way: Manual setup
const postgres = await new PostgreSqlContainer().start();
const minio = await new MinioContainer().start();
const nats = await createNatsContainer().start();
// ... manual cleanup in afterAll

// New Way: Builder composition
const TesterClass = createDefaultTesterBuilder()
  .with(DockerTesterBuilder)
  .with(PostgresTesterBuilder)
  .with(MinioTesterBuilder)
  .with(NatsTesterBuilder)
  .build();

const tester = new TesterClass();
```

### Type-Safe Dependencies

Builders can declare dependencies on other builders. The TypeScript compiler **prevents** you from adding a builder without its dependencies:

```typescript
// This fails at compile time - PostgresTesterBuilder requires DockerTesterBuilder
createTesterBuilder()
  .with(PostgresTesterBuilder)  // Type error!

// This works - dependencies satisfied
createTesterBuilder()
  .with(DockerTesterBuilder)
  .with(PostgresTesterBuilder)

// Most convenient - use default builder which includes DockerTesterBuilder
createDefaultTesterBuilder()
  .with(PostgresTesterBuilder)  // DockerTesterBuilder already included!
```

### Lifecycle Management

Builders manage setup and cleanup automatically:

- **Setup Phase**: Builders execute in the order they're added
- **Destroy Phase**: Builders execute in **reverse order** (LIFO)

```typescript
createTesterBuilder()
  .with(DockerTesterBuilder)      // 1. Create network
  .with(PostgresTesterBuilder)    // 2. Start Postgres
  .with(MinioTesterBuilder)       // 3. Start MinIO
  .build();

// Setup order:    Docker → Postgres → MinIO
// Destroy order:  MinIO → Postgres → Docker  (LIFO!)
```

## Quick Start

### Integration Test Example

Integration tests run your application **in-process** (same Node.js process as the test).

```typescript
import { describe, it, expect, beforeAll, afterAll } from "vitest";
import {
  createDefaultTesterBuilder,
  DockerTesterBuilder,
  PostgresTesterBuilder,
  MinioTesterBuilder,
  NatsTesterBuilder,
  RedisTesterBuilder,
} from "@wallpaperdb/test-utils";
import {
  IngestorMigrationsTesterBuilder,
  InProcessIngestorTesterBuilder,
} from "./builders/index.js";

describe("Health Endpoint", () => {
  const setup = () => {
    const TesterClass = createDefaultTesterBuilder()
      .with(DockerTesterBuilder)
      .with(PostgresTesterBuilder)
      .with(MinioTesterBuilder)
      .with(NatsTesterBuilder)
      .with(RedisTesterBuilder)
      .with(IngestorMigrationsTesterBuilder)
      .with(InProcessIngestorTesterBuilder)
      .build();

    const tester = new TesterClass();

    tester
      .withPostgres((b) => b.withDatabase(`test_health_${Date.now()}`))
      .withMinio()
      .withMinioBucket("wallpapers")
      .withNats((b) => b.withJetstream())
      .withMigrations()
      .withInProcessApp();

    return tester;
  };

  let tester: ReturnType<typeof setup>;

  beforeAll(async () => {
    tester = setup();
    await tester.setup();
  }, 60000);

  afterAll(async () => {
    await tester.destroy();
  });

  it("returns healthy status", async () => {
    const fastify = tester.getApp();
    const response = await fastify.inject({
      method: "GET",
      url: "/health",
    });
    expect(response.statusCode).toBe(200);
  });
});
```

### E2E Test Example

E2E tests run your application **in a Docker container**.

```typescript
import { describe, test, expect, beforeAll, afterAll, afterEach } from "vitest";
import { request } from "undici";
import {
  createDefaultTesterBuilder,
  DockerTesterBuilder,
  PostgresTesterBuilder,
  MinioTesterBuilder,
  NatsTesterBuilder,
  RedisTesterBuilder,
} from "@wallpaperdb/test-utils";
import {
  ContainerizedIngestorTesterBuilder,
  IngestorMigrationsTesterBuilder,
} from "./builders/index.js";

describe("Health Endpoint E2E", () => {
  const setup = () => {
    const TesterClass = createDefaultTesterBuilder()
      .with(DockerTesterBuilder)
      .with(PostgresTesterBuilder)
      .with(MinioTesterBuilder)
      .with(NatsTesterBuilder)
      .with(RedisTesterBuilder)
      .with(IngestorMigrationsTesterBuilder)
      .with(ContainerizedIngestorTesterBuilder)
      .build();

    const tester = new TesterClass();

    tester
      .withPostgres((b) => b.withDatabase(`test_e2e_health_${Date.now()}`))
      .withPostgresAutoCleanup(["wallpapers"])
      .withMinio()
      .withMinioBucket("wallpapers")
      .withMinioAutoCleanup()
      .withNats()
      .withStream("WALLPAPER")
      .withNatsAutoCleanup()
      .withMigrations()
      .withContainerizedApp();

    return tester;
  };

  let tester: ReturnType<typeof setup>;
  let baseUrl: string;

  beforeAll(async () => {
    tester = setup();
    await tester.setup();
    baseUrl = tester.getBaseUrl();
  }, 120000);

  afterAll(async () => {
    await tester.destroy();
  });

  afterEach(async () => {
    await tester.cleanup();
  });

  test("GET /health returns healthy status", async () => {
    const response = await request(`${baseUrl}/health`, { method: "GET" });
    expect(response.statusCode).toBe(200);
  });
});
```

## Available Infrastructure Builders

### DockerTesterBuilder

Provides Docker container management foundation.

**Dependencies:** None

### PostgresTesterBuilder

Manages PostgreSQL database containers.

**Dependencies:** `[DockerTesterBuilder]`

```typescript
tester
  .withPostgres((builder) =>
    builder.withDatabase(`test_db_${Date.now()}`)
  )
  .withPostgresAutoCleanup(["wallpapers", "users"]);
```

### MinioTesterBuilder

Manages MinIO (S3-compatible storage) containers.

**Dependencies:** `[DockerTesterBuilder]`

```typescript
tester
  .withMinio()
  .withMinioBucket("wallpapers")
  .withMinioBucket("thumbnails")
  .withMinioAutoCleanup();
```

### NatsTesterBuilder

Manages NATS messaging containers with JetStream support.

**Dependencies:** `[DockerTesterBuilder]`

```typescript
tester
  .withNats((builder) => builder.withJetstream())
  .withStream("WALLPAPER")
  .withNatsAutoCleanup();
```

### RedisTesterBuilder

Manages Redis cache containers.

**Dependencies:** `[DockerTesterBuilder]`

```typescript
tester.withRedis();
```

## Best Practices

1. **Use `createDefaultTesterBuilder()`** for most tests
2. **Use unique database names** to avoid conflicts
3. **Set generous timeouts** (60s for integration, 120s for E2E)
4. **Always destroy in afterAll**
5. **Use auto-cleanup for test isolation**
6. **Use the `setup()` function pattern** for cleaner type inference
