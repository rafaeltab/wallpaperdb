---
title: Shared Packages
description: Architecture of shared packages in the WallpaperDB monorepo and how they enable rapid multi-service development.
---

This document describes the shared packages in the WallpaperDB monorepo and how they enable rapid multi-service development.

## @wallpaperdb/core

### Purpose

Provides foundational infrastructure patterns that all services need.

### Connections

Factory functions for creating infrastructure connections:

```typescript
import { createPool, checkPoolHealth } from "@wallpaperdb/core/connections";

const pool = createPool({ connectionString: config.databaseUrl });
const healthy = await checkPoolHealth(pool);
```

Services typically extend `BaseConnection`:

```typescript
import { BaseConnection } from "@wallpaperdb/core/connections/base";

@injectable()
export class DatabaseConnection extends BaseConnection {
  async doConnect(): Promise<void> { /* ... */ }
  async doDisconnect(): Promise<void> { /* ... */ }
  async checkHealth(): Promise<boolean> { /* ... */ }
}
```

### Config

Zod-based configuration with composable schemas:

```typescript
import { z } from "zod";
import {
  ServerConfigSchema,
  DatabaseConfigSchema,
} from "@wallpaperdb/core/config";

const configSchema = z.object({
  ...ServerConfigSchema.shape,
  ...DatabaseConfigSchema.shape,
  myOption: z.string().default("default"),
});

export type Config = z.infer<typeof configSchema>;
```

### Health

Health check aggregation with timeout handling:

```typescript
import { HealthAggregator } from "@wallpaperdb/core/health";

const aggregator = new HealthAggregator({ checkTimeoutMs: 5000 });
aggregator.register("database", async () => checkPoolHealth(pool));
aggregator.register("nats", async () => checkNatsHealth(nc));

// Kubernetes-style probes
aggregator.setInitialized(true);   // /ready returns 200
aggregator.setShuttingDown(true);  // /ready returns 503
```

### Telemetry

OpenTelemetry helpers without DI coupling:

```typescript
import { withSpan, Attributes } from "@wallpaperdb/core/telemetry";

async function processUpload(userId: string) {
  return withSpan(
    "upload.process",
    { [Attributes.USER_ID]: userId },
    async (span) => {
      span.addEvent("validation.started");
      return result;
    }
  );
}
```

## @wallpaperdb/events

### Purpose

Event schemas and pub/sub abstractions for inter-service communication.

### Key Principles

1. **Schema Validation** - All events are validated with Zod
2. **Trace Propagation** - OpenTelemetry context propagated in NATS headers
3. **Type Safety** - Full TypeScript support via schema inference

### Event Schemas

```typescript
import { createEventSchema, WallpaperUploadedEventSchema } from "@wallpaperdb/events";

const MyEventSchema = createEventSchema({
  userId: z.string(),
  action: z.enum(["created", "updated"]),
});
```

### Publishers

```typescript
import { BaseEventPublisher } from "@wallpaperdb/events";

class WallpaperUploadedPublisher extends BaseEventPublisher<typeof WallpaperUploadedEventSchema> {
  constructor(js: JetStreamClient) {
    super({
      js,
      subject: WALLPAPER_UPLOADED_SUBJECT,
      schema: WallpaperUploadedEventSchema,
      serviceName: "ingestor",
    });
  }
}
```

### Consumers

```typescript
import { BaseEventConsumer, type MessageContext } from "@wallpaperdb/events";

class WallpaperUploadedConsumer extends BaseEventConsumer<typeof WallpaperUploadedEventSchema> {
  protected async handleMessage(
    event: WallpaperUploadedEvent,
    context: MessageContext
  ): Promise<void> {
    // Process the event
  }
}
```

## Service Integration Pattern

### 1. Create Config

```typescript
import { z } from "zod";
import {
  ServerConfigSchema,
  DatabaseConfigSchema,
  NatsConfigSchema,
} from "@wallpaperdb/core/config";

const configSchema = z.object({
  ...ServerConfigSchema.shape,
  ...DatabaseConfigSchema.shape,
  ...NatsConfigSchema.shape,
});

export function loadConfig() {
  return configSchema.parse({
    port: parseIntEnv(process.env.PORT, 3001),
    databaseUrl: process.env.DATABASE_URL,
    natsUrl: process.env.NATS_URL,
  });
}
```

### 2. Create Connection Managers

```typescript
import { BaseConnection, createPool } from "@wallpaperdb/core/connections";

@injectable()
export class DatabaseConnection extends BaseConnection {
  private pool: Pool | null = null;

  async doConnect() {
    this.pool = createPool({ connectionString: this.config.databaseUrl });
  }

  async doDisconnect() {
    await this.pool?.end();
  }
}
```

### 3. Set Up Health Checks

```typescript
import { HealthAggregator } from "@wallpaperdb/core/health";

@injectable()
export class HealthService {
  private aggregator = new HealthAggregator();

  constructor(
    @inject(DatabaseConnection) db: DatabaseConnection,
    @inject(NatsConnection) nats: NatsConnection,
  ) {
    this.aggregator.register("database", () => db.checkHealth());
    this.aggregator.register("nats", () => nats.checkHealth());
  }
}
```

## Migration Guide

When extracting code to shared packages:

1. **Identify Common Patterns** - Look for code duplicated across services
2. **Extract to Package** - Create new package under `packages/`
3. **Add Tests** - Comprehensive unit tests are required
4. **Update Services** - Import from package instead of local code
5. **Document** - Update this document and package README
