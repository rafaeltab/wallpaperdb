---
title: "@wallpaperdb/events"
description: Event schemas and pub/sub abstractions for WallpaperDB services
---

The `@wallpaperdb/events` package provides Zod-based event schemas and abstract base classes for publishing and consuming events via NATS JetStream. It includes automatic OpenTelemetry trace context propagation for distributed tracing across services.

## Installation

```bash
pnpm add @wallpaperdb/events
```

## Overview

This package provides three main components:

1. **Event Schemas** - Zod schemas for validating event payloads
2. **BaseEventPublisher** - Abstract class for publishing events to NATS JetStream
3. **BaseEventConsumer** - Abstract class for consuming events from NATS JetStream

All components include built-in OpenTelemetry trace context propagation for end-to-end distributed tracing.

## Event Schemas

### WallpaperUploaded Event

The `WallpaperUploadedEventSchema` is published when a wallpaper is successfully uploaded and stored.

```typescript
import {
  WallpaperUploadedEventSchema,
  WALLPAPER_UPLOADED_SUBJECT,
  type WallpaperUploadedEvent
} from "@wallpaperdb/events";

// Subject: "wallpaper.uploaded"
// Events use a nested envelope structure with metadata + payload
const event: WallpaperUploadedEvent = {
  eventId: "01HABCDEF123456789",           // ULID, auto-generated
  eventType: "wallpaper.uploaded",         // Event type identifier
  timestamp: "2024-01-01T00:00:00.000Z",   // ISO 8601, auto-generated
  wallpaper: {                              // Nested payload
    id: "wlpr_01HABCDEF123456789",
    userId: "user_123",
    fileType: "image",
    mimeType: "image/jpeg",
    fileSizeBytes: 1024000,
    width: 1920,
    height: 1080,
    aspectRatio: 1.7778,                    // Number, not string
    storageKey: "wlpr_01HABCDEF123456789/original.jpg",
    storageBucket: "wallpapers",
    originalFilename: "my-wallpaper.jpg",
    uploadedAt: "2024-01-01T00:00:00.000Z"
  }
};

// Validate
const validated = WallpaperUploadedEventSchema.parse(event);
```

**Event Envelope Fields:**
- `eventId` - Unique event identifier (ULID)
- `eventType` - Event type (`"wallpaper.uploaded"`)
- `timestamp` - ISO 8601 timestamp when event was created

**Wallpaper Payload Fields:**
- `id` - Wallpaper ID (format: `wlpr_<ulid>`)
- `userId` - User who uploaded the wallpaper
- `fileType` - `"image"` or `"video"`
- `mimeType` - MIME type (e.g., `"image/jpeg"`)
- `fileSizeBytes` - File size in bytes
- `width`, `height` - Dimensions in pixels
- `aspectRatio` - Decimal aspect ratio (number)
- `storageKey` - S3 object key
- `storageBucket` - S3 bucket name
- `originalFilename` - Original filename from upload
- `uploadedAt` - ISO 8601 timestamp of upload

### Creating Custom Event Schemas

While not explicitly exported, you can create custom events following the same pattern:

```typescript
import { z } from "zod";

export const MyCustomEventSchema = z.object({
  // Add your event-specific fields
  resourceId: z.string(),
  action: z.enum(["created", "updated", "deleted"]),
  timestamp: z.string().datetime(),
  metadata: z.record(z.string(), z.unknown()).optional()
});

export type MyCustomEvent = z.infer<typeof MyCustomEventSchema>;
export const MY_CUSTOM_EVENT_SUBJECT = "my.custom.event";
```

## BaseEventPublisher

Abstract class for publishing events with automatic validation and trace context propagation.

### Basic Usage

```typescript
import { BaseEventPublisher, type EventPublisherConfig } from "@wallpaperdb/events";
import type { NatsConnection } from "nats";
import { z } from "zod";

// Define your event schema with envelope structure
const MyEventSchema = z.object({
  eventId: z.string(),
  eventType: z.literal("my.event"),
  timestamp: z.string().datetime(),
  payload: z.object({
    id: z.string(),
    action: z.string(),
    data: z.record(z.string(), z.unknown())
  })
});

class MyEventPublisher extends BaseEventPublisher<typeof MyEventSchema> {
  protected readonly schema = MyEventSchema;
  protected readonly subject = "my.event.subject";
  protected readonly eventType = "my.event";

  constructor(config: EventPublisherConfig) {
    super(config);
  }
}

// Usage
const natsConnection: NatsConnection = /* ... */;
const publisher = new MyEventPublisher({
  natsConnection,
  serviceName: "my-service"
});

// Publish with auto-generated envelope fields
await publisher.publishNew({
  payload: {
    id: "123",
    action: "created",
    data: { foo: "bar" }
  }
});
```

### Example: Implementing a WallpaperUploaded Publisher

Note: `WallpaperUploadedPublisher` is not exported from `@wallpaperdb/events`. This is an example of how you would implement it in your service:

```typescript
import {
  BaseEventPublisher,
  WallpaperUploadedEventSchema,
  WALLPAPER_UPLOADED_SUBJECT,
  type EventPublisherConfig,
  type WallpaperUploadedEvent
} from "@wallpaperdb/events";

class WallpaperUploadedPublisher extends BaseEventPublisher<typeof WallpaperUploadedEventSchema> {
  protected readonly schema = WallpaperUploadedEventSchema;
  protected readonly subject = WALLPAPER_UPLOADED_SUBJECT;
  protected readonly eventType = "wallpaper.uploaded";
}

// Usage in your service (e.g., ingestor)
const publisher = new WallpaperUploadedPublisher({
  natsConnection,
  serviceName: "ingestor"
});

// Publish with auto-generated eventId and timestamp
await publisher.publishNew({
  wallpaper: {
    id: "wlpr_01HABCDEF123456789",
    userId: "user_123",
    fileType: "image",
    mimeType: "image/jpeg",
    fileSizeBytes: 1024000,
    width: 1920,
    height: 1080,
    aspectRatio: 1.7778,
    storageKey: "wlpr_01HABCDEF123456789/original.jpg",
    storageBucket: "wallpapers",
    originalFilename: "my-wallpaper.jpg",
    uploadedAt: "2024-01-01T00:00:00.000Z"
  }
});
```

### Features

#### Schema Validation
Events are validated against the Zod schema before publishing. Invalid events throw validation errors.

```typescript
// This will throw a Zod validation error
await publisher.publish({
  id: 123, // Wrong type! Should be string
  action: "created"
});
```

#### Trace Context Propagation

The publisher automatically injects OpenTelemetry trace context into NATS message headers:

```typescript
// Trace context is automatically propagated
await withSpan("upload.process", {}, async () => {
  // This publish will include trace context in headers
  await publisher.publish(event);
  // Downstream consumers can extract and continue the trace
});
```

Headers added:
- `traceparent` - W3C Trace Context traceparent header
- `tracestate` - W3C Trace Context tracestate header (if present)

#### Publish Acknowledgment

The `publish()` method returns a NATS `PubAck` for durability guarantees:

```typescript
const ack = await publisher.publish(event);
console.log(`Published to stream ${ack.stream}, sequence ${ack.seq}`);
```

## BaseEventConsumer

Abstract class for consuming events with automatic validation, trace context extraction, and error handling.

### Basic Usage

```typescript
import { BaseEventConsumer, type MessageContext, type EventConsumerConfig } from "@wallpaperdb/events";
import type { NatsConnection } from "nats";
import { z } from "zod";

const MyEventSchema = z.object({
  eventId: z.string(),
  eventType: z.literal("my.event"),
  timestamp: z.string().datetime(),
  payload: z.object({
    id: z.string(),
    action: z.string(),
    data: z.record(z.string(), z.unknown())
  })
});

class MyEventConsumer extends BaseEventConsumer<typeof MyEventSchema> {
  protected readonly schema = MyEventSchema;
  protected readonly subject = "my.event.subject";
  protected readonly eventType = "my.event";

  constructor(config: EventConsumerConfig) {
    super(config);
  }

  protected async handleEvent(
    event: z.infer<typeof MyEventSchema>,
    context: MessageContext
  ): Promise<void> {
    console.log(`Processing event ${event.eventId}`);

    // Access message metadata
    console.log(`Event ID: ${context.eventId}`);
    console.log(`Timestamp: ${context.timestamp}`);
    console.log(`Delivery attempt: ${context.deliveryAttempt}`);
    console.log(`Stream: ${context.stream}`);
    console.log(`Consumer: ${context.consumer}`);

    // Do processing...
    await processEvent(event.payload);

    // Message is automatically acked on success
  }
}

// Usage
const natsConnection: NatsConnection = /* ... */;
const consumer = new MyEventConsumer({
  natsConnectionProvider: () => natsConnection,
  serviceName: "my-service",
  streamName: "MY_STREAM",
  durableName: "my-consumer"
});

await consumer.start();

// Later, when shutting down
await consumer.stop();
```

### MessageContext

The `MessageContext` provides access to event metadata and NATS message information:

```typescript
interface MessageContext {
  eventId: string;           // Unique event identifier from event payload
  timestamp: string;         // ISO 8601 timestamp from event payload
  headers: Record<string, string | undefined>;  // NATS message headers
  deliveryAttempt: number;   // Number of times this message has been delivered
  stream: string;            // Name of the JetStream stream
  consumer: string;          // Name of the consumer
}
```

### Features

#### Schema Validation
Events are validated before being passed to `handleEvent()`. Invalid messages are terminated (not retried) since they won't pass validation on subsequent attempts.

#### Automatic Acknowledgment
- **Success**: Message is acked automatically when `handleEvent()` completes successfully
- **Error**: Message is nacked for retry if `handleEvent()` throws an error
- **Max Retries**: Message is terminated after exceeding `maxRetries` (default: 3)

```typescript
protected async handleEvent(event: MyEvent, context: MessageContext): Promise<void> {
  // If this throws, message is nacked and will be retried
  await riskyOperation(event);

  // If we reach here, message is acked
}
```

#### Trace Context Extraction

The consumer automatically extracts OpenTelemetry trace context from NATS message headers and creates a span for each message:

```typescript
// Trace context is automatically extracted and continued
protected async handleEvent(event: MyEvent, context: MessageContext): Promise<void> {
  // This span is linked to the publisher's trace
  await withSpan("event.process", { eventId: event.eventId }, async () => {
    await processEvent(event.payload);
  });
}
```

This enables end-to-end distributed tracing across services!

#### Error Handling

Consumers include built-in error handling:

```typescript
protected async handleEvent(event: MyEvent, context: MessageContext): Promise<void> {
  try {
    await processEvent(event.payload);
  } catch (error) {
    // Log error, add context
    console.error("Failed to process event", { eventId: event.eventId, error });

    // Re-throw to nack the message for retry
    throw error;
  }
}
```

## Complete Example: Thumbnail Service

Here's a complete example of a service that consumes wallpaper upload events and generates thumbnails:

```typescript
import "reflect-metadata";
import { BaseEventConsumer, type MessageContext, type EventConsumerConfig } from "@wallpaperdb/events";
import { WallpaperUploadedEventSchema, WALLPAPER_UPLOADED_SUBJECT } from "@wallpaperdb/events";
import type { NatsConnection } from "nats";
import { withSpan } from "@wallpaperdb/core/telemetry";
import { Attributes } from "@wallpaperdb/core/telemetry/attributes";

class WallpaperUploadedConsumer extends BaseEventConsumer<typeof WallpaperUploadedEventSchema> {
  protected readonly schema = WallpaperUploadedEventSchema;
  protected readonly subject = WALLPAPER_UPLOADED_SUBJECT;
  protected readonly eventType = "wallpaper.uploaded";

  constructor(
    config: EventConsumerConfig,
    private thumbnailService: ThumbnailService
  ) {
    super(config);
  }

  protected async handleEvent(
    event: z.infer<typeof WallpaperUploadedEventSchema>,
    context: MessageContext
  ): Promise<void> {
    return await withSpan(
      "wallpaper.thumbnail.generate",
      {
        [Attributes.WALLPAPER_ID]: event.wallpaper.id,
        [Attributes.USER_ID]: event.wallpaper.userId,
        [Attributes.FILE_TYPE]: event.wallpaper.fileType
      },
      async (span) => {
        console.log(`Generating thumbnail for ${event.wallpaper.id}`);

        // Download original from S3
        const imageData = await this.thumbnailService.download(
          event.wallpaper.storageBucket,
          event.wallpaper.storageKey
        );

        // Generate thumbnails
        const thumbnails = await this.thumbnailService.generateThumbnails(imageData);

        // Upload thumbnails to S3
        await this.thumbnailService.uploadThumbnails(
          event.wallpaper.id,
          thumbnails
        );

        span.setAttribute("thumbnails.count", thumbnails.length);
        console.log(`Generated ${thumbnails.length} thumbnails for ${event.wallpaper.id}`);
      }
    );
  }
}

// Start the service
const natsConnection: NatsConnection = /* ... */;
const consumer = new WallpaperUploadedConsumer(
  {
    natsConnectionProvider: () => natsConnection,
    serviceName: "thumbnail-service",
    streamName: "WALLPAPERS",
    durableName: "thumbnail-generator"
  },
  thumbnailService
);
await consumer.start();
console.log("Thumbnail service started");

// Graceful shutdown
process.on("SIGTERM", async () => {
  console.log("Shutting down...");
  await consumer.stop();
  process.exit(0);
});
```

## Event Subjects and Streams

### Current Events

| Event | Subject | Stream | Description |
|-------|---------|--------|-------------|
| WallpaperUploaded | `wallpaper.uploaded` | `WALLPAPERS` | Wallpaper successfully uploaded and stored |

### Future Events

Planned events for multi-service architecture:

- `wallpaper.thumbnail.generated` - Thumbnails created
- `wallpaper.quality.analyzed` - Quality score calculated
- `wallpaper.colors.extracted` - Color palette extracted
- `wallpaper.tagged` - Tags added

## Testing Event Publishers and Consumers

See [Testing: Integration vs E2E](/docs/testing/integration-vs-e2e) for strategies on testing event-driven services.

```typescript
import { NatsTesterBuilder } from "@wallpaperdb/test-utils";

describe("WallpaperUploadedPublisher", () => {
  it("should publish events to NATS", async () => {
    const tester = await new NatsTesterBuilder()
      .withNats()
      .build();

    const js = tester.nats.jetstream();
    const publisher = new WallpaperUploadedPublisher(js);

    const event = { /* ... */ };
    const ack = await publisher.publish(event);

    expect(ack.stream).toBe("WALLPAPERS");
  });
});
```

## Related Documentation

- [Package: Core](/docs/packages/core) - Infrastructure and telemetry
- [Observability](/docs/observability) - Distributed tracing setup
- [Architecture: Multi-Service](/docs/architecture/multi-service) - Event-driven architecture
- [Testing](/docs/testing) - Testing strategies for event-driven services
