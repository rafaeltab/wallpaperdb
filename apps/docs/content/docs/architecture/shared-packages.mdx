---
title: Shared Packages
description: Architecture of shared packages in the WallpaperDB monorepo and how they enable rapid multi-service development.
---

This document describes the shared packages in the WallpaperDB monorepo and how they enable rapid multi-service development.

## @wallpaperdb/core

**See full documentation:** [Package: Core](/docs/packages/core)

### Purpose

Provides foundational infrastructure patterns that all services need.

### Connections

Connection managers for all infrastructure dependencies:

```typescript
import {
  DatabaseConnection,
  MinioConnection,
  NatsConnectionManager,
  RedisConnection,
  OtelConnection,
} from "@wallpaperdb/core/connections";

// All connections implement BaseConnection interface
@injectable()
export class DatabaseConnection extends BaseConnection {
  async initialize(): Promise<void> { /* ... */ }
  async destroy(): Promise<void> { /* ... */ }
  async checkHealth(): Promise<boolean> { /* ... */ }
}
```

**Available connections:**
- `DatabaseConnection` - PostgreSQL with Drizzle ORM
- `MinioConnection` - S3-compatible object storage
- `NatsConnectionManager` - NATS with JetStream
- `RedisConnection` - Redis with connection pooling
- `OtelConnection` - OpenTelemetry SDK initialization

### Config

Zod-based configuration with composable schemas:

```typescript
import { z } from "zod";
import {
  ServerConfigSchema,
  DatabaseConfigSchema,
} from "@wallpaperdb/core/config";

const configSchema = z.object({
  ...ServerConfigSchema.shape,
  ...DatabaseConfigSchema.shape,
  myOption: z.string().default("default"),
});

export type Config = z.infer<typeof configSchema>;
```

### Health

Health check aggregation with timeout handling:

```typescript
import { HealthAggregator } from "@wallpaperdb/core/health";

const aggregator = new HealthAggregator({ checkTimeoutMs: 5000 });
aggregator.register("database", async () => checkPoolHealth(pool));
aggregator.register("nats", async () => checkNatsHealth(nc));

// Kubernetes-style probes
aggregator.setInitialized(true);   // /ready returns 200
aggregator.setShuttingDown(true);  // /ready returns 503
```

### Telemetry

OpenTelemetry helpers without DI coupling:

```typescript
import { withSpan, Attributes } from "@wallpaperdb/core/telemetry";

async function processUpload(userId: string) {
  return withSpan(
    "upload.process",
    { [Attributes.USER_ID]: userId },
    async (span) => {
      span.addEvent("validation.started");
      return result;
    }
  );
}
```

## @wallpaperdb/events

**See full documentation:** [Package: Events](/docs/packages/events)

### Purpose

Event schemas and pub/sub abstractions for inter-service communication.

### Key Principles

1. **Schema Validation** - All events are validated with Zod
2. **Trace Propagation** - OpenTelemetry context propagated in NATS headers
3. **Type Safety** - Full TypeScript support via schema inference

### Event Schemas

```typescript
import { createEventSchema, WallpaperUploadedEventSchema } from "@wallpaperdb/events";

const MyEventSchema = createEventSchema({
  userId: z.string(),
  action: z.enum(["created", "updated"]),
});
```

### Publishers

```typescript
import { BaseEventPublisher } from "@wallpaperdb/events";

class WallpaperUploadedPublisher extends BaseEventPublisher<typeof WallpaperUploadedEventSchema> {
  constructor(js: JetStreamClient) {
    super({
      js,
      subject: WALLPAPER_UPLOADED_SUBJECT,
      schema: WallpaperUploadedEventSchema,
      serviceName: "ingestor",
    });
  }
}
```

### Consumers

```typescript
import { BaseEventConsumer, type MessageContext } from "@wallpaperdb/events";

class WallpaperUploadedConsumer extends BaseEventConsumer<typeof WallpaperUploadedEventSchema> {
  protected async handleMessage(
    event: WallpaperUploadedEvent,
    context: MessageContext
  ): Promise<void> {
    // Process the event
  }
}
```

## Service Integration Pattern

### 1. Create Config

```typescript
import { z } from "zod";
import {
  ServerConfigSchema,
  DatabaseConfigSchema,
  NatsConfigSchema,
} from "@wallpaperdb/core/config";

const configSchema = z.object({
  ...ServerConfigSchema.shape,
  ...DatabaseConfigSchema.shape,
  ...NatsConfigSchema.shape,
});

export function loadConfig() {
  return configSchema.parse({
    port: parseIntEnv(process.env.PORT, 3001),
    databaseUrl: process.env.DATABASE_URL,
    natsUrl: process.env.NATS_URL,
  });
}
```

### 2. Create Connection Managers

```typescript
import { BaseConnection, createPool } from "@wallpaperdb/core/connections";

@injectable()
export class DatabaseConnection extends BaseConnection {
  private pool: Pool | null = null;

  async doConnect() {
    this.pool = createPool({ connectionString: this.config.databaseUrl });
  }

  async doDisconnect() {
    await this.pool?.end();
  }
}
```

### 3. Set Up Health Checks

```typescript
import { HealthAggregator } from "@wallpaperdb/core/health";

@injectable()
export class HealthService {
  private aggregator = new HealthAggregator();

  constructor(
    @inject(DatabaseConnection) db: DatabaseConnection,
    @inject(NatsConnection) nats: NatsConnection,
  ) {
    this.aggregator.register("database", () => db.checkHealth());
    this.aggregator.register("nats", () => nats.checkHealth());
  }
}
```

## Other Packages

### @wallpaperdb/test-utils

**See full documentation:** [Package: Test Utils](/docs/packages/test-utils)

Composable test infrastructure using the TesterBuilder pattern.

**Key features:**
- Container reuse across test files
- Type-safe builder composition
- Integration and E2E test support
- Automatic cleanup

### @wallpaperdb/testcontainers

**See full documentation:** [Package: Testcontainers](/docs/packages/testcontainers)

Custom Testcontainers implementations for NATS, PostgreSQL, MinIO, and Redis.

### @wallpaperdb/url-ipv4-resolver

**See full documentation:** [Package: URL IPv4 Resolver](/docs/packages/url-ipv4-resolver)

URL validation and DNS resolution to IPv4 for SSRF prevention.

**Key features:**
- URL validation and parsing
- DNS resolution to IPv4
- IPv4 literal detection
- SSRF attack prevention

## Migration Guide

When extracting code to shared packages:

1. **Identify Common Patterns** - Look for code duplicated across services
2. **Extract to Package** - Create new package under `packages/`
3. **Add Tests** - Comprehensive unit tests are required
4. **Update Services** - Import from package instead of local code
5. **Document** - Update this document and package README
